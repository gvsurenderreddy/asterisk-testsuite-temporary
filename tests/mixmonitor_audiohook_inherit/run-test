#!/usr/bin/env python
'''
Copyright (C) 2010, Digium, Inc.
David Vossel <dvossel@digium.com>

This program is free software, distributed under the terms of
the GNU General Public License Version 2.
'''

import sys
import os
import math
from twisted.internet import reactor
from starpy import manager

sys.path.append("lib/python")
from asterisk.asterisk import Asterisk

workingdir = "mixmonitor_audiohook_inherit"
testdir = "tests/%s" % workingdir

class MixMonitorTest:
    def __init__(self):
        self.passed = False
        self.last_step = ""
        # if audiohook inherit does not work, file will be much smaller than 150000 bytes
        self.expectedfilesize = 120000
        self.audiofile1size = -1

        reactor.callWhenRunning(self.run)

        self.ast1 = Asterisk(base=workingdir)
        self.ast1.install_configs("%s/configs/ast1" % (testdir))
        self.audiofile1 = os.path.join(os.getcwd(), "%s/testaudio1" % (testdir))

    def stop_reactor(self):
        print "Stopping Reactor ..."
        if reactor.running:
            reactor.stop()

    def read_result(self):
        self.passed = True
        self.stop_reactor()

        self.log_last_step("Reading result file from MixMonitor")
        if os.path.exists(self.audiofile1 + ".raw"):
            self.audiofile1size = os.path.getsize(self.audiofile1 + ".raw")

        self.log_last_step("audiofile1 size is %d, a negative size indicates the file was not present." % (self.audiofile1size, ))
        if self.audiofile1size < self.expectedfilesize:
            # if this failed mixmonitor is not creating the correct file size for the time we expect.
            self.log_last_step("audiofile1 size is not within the size tolerance.")
            self.passed = False

        if self.passed == True:
            self.log_last_step("Test Passed... All audio files are the correct.")

    def launch_test1(self):
        self.log_last_step("Placing call to test1 exten")
        self.ast1.cli_originate("Local/s@listener extension 101@ast1")

    def check_test1(self, ami, event):
        self.log_last_step("Checking Userevent")
        if event.get("userevent").lower() != "test1":
            return
        status = event.get("status")
        print ("Status of test1 is %s" % (status))
        if status != "SUCCESS":
            self.stop_reactor()
            return

        self.read_result()

    def ami_on_connect1(self, ami):
        self.log_last_step("Connected to AMI 1")
        self.ami = ami
        self.ami.registerEvent("UserEvent", self.check_test1)

    def ami_login_error(self, ami):
        self.log_last_step("AMI login failed")
        self.stop_reactor()

    def ami_login(self):
        self.log_last_step("Logging in to the AMI")
        self.ami_factory1 = manager.AMIFactory("user", "mysecret")
        self.ami_factory1.login('127.0.0.1', 5038).addCallbacks(self.ami_on_connect1, self.ami_login_error)

    def start_asterisk(self):
        self.log_last_step("Starting Asterisk")
        self.ast1.start()

        self.ast1.cli_exec("core set global TESTAUDIO1 " + self.audiofile1)

    def stop_asterisk(self):
        self.ast1.stop()

    def log_last_step(self, step):
        print step
        self.last_step = step

    def run(self):
        self.ami_login()
        self.launch_test1()

        reactor.callLater(60, self.stop_reactor)

def main():
    test = MixMonitorTest()
    test.start_asterisk()
    reactor.run()
    test.stop_asterisk()
    if test.passed:
        return 0
    return 1

if __name__ == "__main__":
    sys.exit(main() or 0)

# vim:sw=4:ts=4:expandtab:textwidth=79
