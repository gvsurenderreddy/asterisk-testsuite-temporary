#!/usr/bin/env python
# vim: sw=3 et:
'''
Copyright (C) 2011, Digium, Inc.
Matt Jordan <mjordan@digium.com>

This program is free software, distributed under the terms of
the GNU General Public License Version 2.
'''

import sys
import os
import logging

from twisted.internet import reactor

sys.path.append("lib/python")

from asterisk.asterisk import Asterisk
from asterisk.TestCase import TestCase
from asterisk.TestState import TestStateController
from asterisk.TestState import TestState
from asterisk.TestState import FailureTestState
from asterisk.voicemail import VoiceMailMailboxManagement
from asterisk.voicemail import TestCondition
from asterisk.voicemail import VoiceMailTest
from asterisk.voicemail import VoiceMailState

logger = logging.getLogger(__name__)

"""
TestState that is the entry point for the VoiceMailMain application
"""
class StartVoiceMailState(VoiceMailState):

    userPassword = "1234#"

    def __init__(self, controller, voiceMailTest):
        VoiceMailState.__init__(self, controller, voiceMailTest)

    def handleStateChange(self, ami, event):
        state = event['state']

        if state == 'PLAYBACK':
            """
            While we're in the START state, we have to authenticate the user.  If we see the login or password
            prompts, send in our login / password
            """
            message = event['message']
            if message == 'vm-password':
                self.voiceMailTest.sendDTMF(self.userPassword)
        elif state == 'AUTHENTICATED':
            self.changeState(AuthenticatedTestState(self.controller, self.voiceMailTest))
        else:
            self.handleDefaultState(event)

    def getStateName(self):
        return "START"


"""
TestState that occurs after a user has been authenticated
"""
class AuthenticatedTestState(VoiceMailState):


    def __init__(self, controller, voiceMailTest):
        VoiceMailState.__init__(self, controller, voiceMailTest)


    def handleStateChange(self, ami, event):
        state = event['state']

        if state == 'AUTHENTICATED':
            logger.error("Received two authenticated events?")
            self.changeState(FailureTestState(self.controller, self.voiceMailTest))
        elif state == 'INTRO':
            self.changeState(IntroTestState(self.controller, self.voiceMailTest))
        elif state == 'PLAYBACK':
            message = event['message']

            """
            The only prompt that we care about in this state is if we get a notification that we are a new user.
            Since this mailbox shouldn't be marked as such, this would constitute an error
            """
            if message == 'new user':
                logger.error("new user played; user credentials must have failed")
                self.changeState(FailureTestState(self.controller))
        else:
            self.handleDefaultState(event)


    def getStateName(self):
        return "AUTHENTICATED"


"""
TestState that occurs after when the user is being presented with the initial message counts and the main
voicemail menu
"""
class IntroTestState(VoiceMailState):


    def __init__(self, controller, voiceMailTest):
        VoiceMailState.__init__(self, controller, voiceMailTest)

    def handleStateChange(self, ami, event):
        state = event['state']

        if state == 'BROWSE':
            self.changeState(BrowseMessageTestState(self.controller, self.voiceMailTest))
        elif state == 'PLAYBACK':
            message = event['message']

            if message == 'instructions':
                """
                Tell it to play the first message
                """
                self.voiceMailTest.sendDTMF("1")
        else:
            self.handleDefaultState(event)


    def getStateName(self):
        return "INTRO"


"""
TestState that occurs when a user chooses to play a message
"""
class BrowseMessageTestState(VoiceMailState):


    def __init__(self, controller, voiceMailTest):
        VoiceMailState.__init__(self, controller, voiceMailTest)

    def handleStateChange(self, ami, event):
        state = event['state']

        if state == 'PLAYVOICE':
            self.changeState(PlayVoiceMailTestState(self.controller, self.voiceMailTest))
        elif state == 'PLAYBACK':
            message = event['message']

            if message == 'instructions':
                """ Tell it to save the message """
                self.voiceMailTest.sendDTMF("9")
            elif message == 'vm-Urgent':
                self.voiceMailTest.setTestCondition("urgent", True)
            elif message == 'vm-nomore':
                """ Exit voicemail """
                self.voiceMailTest.sendDTMF("#")
        else:
            self.handleDefaultState(event)


    def getStateName(self):
        return "BROWSE"


"""
TestState that occurs when the actual voicemail is being played back to the user
"""
class PlayVoiceMailTestState(VoiceMailState):


    def __init__(self, controller, voiceMailTest):
        VoiceMailState.__init__(self, controller, voiceMailTest)

        """ Notify the test that we heard a message """
        self.voiceMailTest.setTestCondition("messagesHeard", 1)

        if not self.voiceMailTest.getTestCondition("urgent"):
            """ The first message we heard was not urgent; fail the test """
            logger.error("Heard normal priority message before urgent message")
            self.changeState(FailureTestState(self.controller))


    def handleStateChange(self, ami, event):
        state = event['state']

        if state == 'SAVEMSG':
            self.changeState(SaveMessageTestState(self.controller, self.voiceMailTest))
        elif state == 'PLAYBACK':
            message = event['message']

            if message == 'instructions':
                """ Instruct the server to save the voicemail """
                self.voiceMailTest.sendDTMF("9")
        else:
            self.handleDefaultState(event)


    def getStateName(self):
        return "PLAYVOICE"


"""
TestState that occurs when the voicemail menu for saving a voicemail is being played
"""
class SaveMessageTestState(VoiceMailState):


    def __init__(self, controller, voiceMailTest):
        VoiceMailState.__init__(self, controller, voiceMailTest)

    def handleStateChange(self, ami, event):
        state = event['state']

        if state == 'PLAYBACK':
            message = event['message']

            if message == 'instructions':
                """ Tell it to save the message """
                self.voiceMailTest.sendDTMF("9")
            elif message == 'vm-savefolder':
                """ Save to old folder """
                self.voiceMailTest.sendDTMF('1')
            elif message == 'vm-savedto':
                """ Notify the test that we saved a message """
                self.voiceMailTest.setTestCondition("savedMessages", 1)
                self.changeState(PlayNextMessageTestState(self.controller, self.voiceMailTest))
        else:
            self.handleDefaultState(event)


    def getStateName(self):
        return "SAVEMSG"


"""
TestState that occurs between saving a message and browsing (or playing) the next message
"""
class PlayNextMessageTestState(VoiceMailState):


    def __init__(self, controller, voiceMailTest):
        VoiceMailState.__init__(self, controller, voiceMailTest)

    def handleStateChange(self, ami, event):
        state = event['state']

        if state == 'PLAYBACK':
            message = event['message']

            if message == 'instructions':
                """ Tell it to play the next the message """
                self.voiceMailTest.sendDTMF("6")
                self.changeState(BrowseMessageTestState(self.controller, self.voiceMailTest))
        else:
            self.handleDefaultState(event)


    def getStateName(self):
        return "PLAYNEXT"


"""
The TestCase class that executes the test
"""
class CheckVoicemailNominal(VoiceMailTest):

    """
    The channel to connect to that acts as the voicemail server
    """
    channel = "sip/ast1/8052"

    """
    The voicemail manager object
    """
    voicemailManager = None

    def __init__(self):
        super(CheckVoicemailNominal, self).__init__()

        """
        Add our test conditions to the test - these will help us verify through the
        state changes whether or not we've passed or failed
        """
        def checkUrgentCondition(value, testCondition):
            return value
        self.addTestCondition("urgent", TestCondition(checkUrgentCondition))

        def checkMessagesHeard(value, testCondition):
            testCondition.testConditionData += value
            if (testCondition.testConditionData == 3):
                return True
            return False
        self.addTestCondition("messagesHeard", TestCondition(checkMessagesHeard, 0))

        def checkSavedMessages(value, testCondition):
            testCondition.testConditionData += value
            if (testCondition.testConditionData == 3):
                return True
            return False
        self.addTestCondition("savedMessages", TestCondition(checkSavedMessages, 0))

        """ Force this test not to timeout.  On bamboo, this test can take a *very* long time """
        self.reactor_timeout = 0
        self.create_asterisk(2)

    def ami_connect(self, ami):
        super(CheckVoicemailNominal, self).ami_connect(ami)

        """ Record which AMI instance we've received and attempt to set up the test controller """
        if (ami.id == 0):
            self.amiReceiver = ami
        elif (ami.id == 1):
            self.amiSender = ami
            self.astSender = self.ast[self.amiSender.id]

        self.createTestController()
        if (self.testStateController != None):
            startObject = StartVoiceMailState(self.testStateController, self)
            self.testStateController.changeState(startObject)
            self.testStateController.addAssertHandler(self.handleAssert)

        """ Now do specific processing on the AMI instances """
        if (ami.id == 0):

            ami.registerEvent('UserEvent', self.user_event)

            """
            Create some dummy voicemails in a valid voicemailbox - 1 urgent, 2 new, 2 old
            """
            self.voicemailManager = VoiceMailMailboxManagement(self.ast[0])
            self.voicemailManager.createMailbox("default", "1234", True)

            logger.debug("Creating dummy voicemails")
            for i in range(0, 2):
                if not self.voicemailManager.createDummyVoicemail("default","1234", self.voicemailManager.inboxFolderName, i, self.formats):
                    logger.error("Failed to create voicemails in folder " + self.voicemailManager.inboxFolderName)
                    self.stop_reactor()
            for i in range(0, 1):
                if not self.voicemailManager.createDummyVoicemail("default", "1234", self.voicemailManager.urgentFolderName, i, self.formats):
                    logger.error("Failed to create voicemails in folder " + self.voicemailManager.urgentFolderName)
                    self.stop_reactor()
            for i in range(0, 2):
                if not self.voicemailManager.createDummyVoicemail("default", "1234", self.voicemailManager.oldFolderName, i, self.formats):
                    logger.error("Failed to create voicemails in folder " + self.voicemailManager.oldFolderName)
                    self.stop_reactor()
        else:
            logger.debug("Originating call to " + self.channel)
            df = ami.originate(self.channel, "voicemailCaller", "wait", 1)
            df.addErrback(self.handleOriginateFailure)

    def handleAssert(self, event):
        self.passed = False
        logger.error("Test Failed - Assert received")
        logger.error("\t\t AppFunction: " + event['appfunction'])
        logger.error("\t\t AppLine: " + event['appline'])
        logger.error("\t\t Expression: " + event['expression'])

        self.stop_reactor()

    def user_event(self, ami, event):
        if event['userevent'] != 'TestResult':
            return

        if event['result'] == "pass":
            self.passed = True
            logger.info("VoiceMail successfully exited")
        else:
            logger.warn("VoiceMail did not successfully exit:")
            logger.warn("result: %s" % (event['result'],))
            logger.warn("error: %s" % (event['error'],))

        self.stop_reactor()


    def run(self):
        super(CheckVoicemailNominal, self).run()
        self.create_ami_factory(2)


def main():

    test = CheckVoicemailNominal()
    voicemailManager = VoiceMailMailboxManagement(test.ast[0])

    test.start_asterisk()

    reactor.run()

    test.stop_asterisk()

    """
    Post-test processing - verify that we listened to all the messages we wanted to listen to, that
    we saved the messages, and that the messages were moved successfully
    """
    if test.passed:

        if not test.checkTestConditions():
            logger.warn("Test failed condition checks")
            test.passed = False

        formats = ["ulaw","wav","WAV"]
        if voicemailManager.checkVoicemailExists("default","1234", 0, formats, "INBOX"):
            logger.warn("Voicemail left in INBOX - should have been saved to old")
            test.passed = False
        if voicemailManager.checkVoicemailExists("default","1234", 0, formats, "Urgent"):
            logger.warn("Voicemail left in Urgent - should have been saved to old")
            test.passed = False
        for i in range(0, 5):
            if not voicemailManager.checkVoicemailExists("default","1234", i, formats, "Old"):
                logger.warn("Failed to find voicemail [" + str(i) + "] in folder Old")
                test.passed = False

    if not test.passed:
        return 1

    return 0

if __name__ == "__main__":
   sys.exit(main() or 0)
