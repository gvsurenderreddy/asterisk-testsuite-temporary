#!/usr/bin/env python
# vim: sw=3 et:
'''
Copyright (C) 2012, Digium, Inc.
Jonathan Rose <jrose@digium.com>

This program is free software, distributed under the terms of
the GNU General Public License Version 2.
'''

import sys
import os
import logging
import re


from twisted.internet import reactor

sys.path.append("lib/python")

from asterisk.TestCase import TestCase

logger = logging.getLogger(__name__)


class BridgeBaseline(TestCase):

    def __init__(self):
        TestCase.__init__(self)
        self.create_asterisk()

    def run(self):
        TestCase.run(self)
        self.create_ami_factory()

    def ami_connect(self, ami):
        TestCase.ami_connect(self, ami)
        """ Register for all events we care about """

        ami.registerEvent("BridgeExec", self.bridge_event)
        ami.registerEvent("UserEvent", self.do_bridge)
        #originate the bridgee
        df = ami.originate(channel = "Local/local@call1", exten = "call", context = "test_context", priority = 1)
        df.addErrback(self.handleOriginateFailure)

    def do_bridge(self, ami, event):
        if (event.get('userevent') != 'StartBridge'):
            return
        #originate the bridger
        df = ami.originate(channel = "Local/local@call2", exten = "bridge", context = "test_context", priority = 1)
        df.addErrback(self.handleOriginateFailure)

    def bridge_event(self, ami, event):
        #passes_needed should match the number of conditions
        passes_needed = 3

        #Condition 1: Event response must be Success to indicate successful bridge
        if (event.get('response') == 'Success'):
            passes_needed = passes_needed - 1
        else:
            logger.error( "Test failed, bridge event didn't indicate success." )

        #Condition 2: The first channel name must start similar to what is indicated below
        if event.get('channel1') and (self.match_starts("Local/local@call2-", event.get('channel1'))):
            passes_needed = passes_needed - 1
        else:
            logger.error( "Failed to match channel1" )

        #Condition 3: The second channel name must start similar to what is indicated below
        if event.get('channel2') and (self.match_starts("Local/local@call1-", event.get('channel2'))):
            passes_needed = passes_needed - 1
        else:
            logger.error( "Failed to match channel2" )

        #Evaluate whether the number of conditions passed matched expectations to determine
        #Success or Failure of the test.
        if (passes_needed == 0):
            logger.info("Test Successful")
            self.passed = True
        else:
            logger.error("Test FAILED")
            self.passed = False
        ami.hangup(event.get('channel1')).addCallback(self.hangup)

    def hangup(self, ami):
        self.stop_reactor()

    def match_starts(self, string1, string2):
        pattern = re.compile(string1)
        if not (pattern.match(string2)):
            return False
        else:
            return True

def main():
    test = BridgeBaseline()
    reactor.run()

    if (test.passed):
        return 0
    else:
        return 1

if __name__ == "__main__":
   sys.exit(main() or 0)
