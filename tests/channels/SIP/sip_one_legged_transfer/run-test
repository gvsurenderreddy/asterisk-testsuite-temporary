#!/usr/bin/env python
'''
Copyright (C) 2010, Digium, Inc.
David Vossel <dvossel@digium.com>

This program is free software, distributed under the terms of
the GNU General Public License Version 2.
'''

import sys
import os
import signal
import subprocess
import logging

from twisted.application import service, internet
from twisted.internet import reactor, defer
from starpy import manager

sys.path.append("lib/python")
from asterisk.asterisk import Asterisk
from asterisk.TestCase import TestCase

logger = logging.getLogger(__name__)

class OneLeggedTransfer(TestCase):
    def __init__(self):
        TestCase.__init__(self)
        self.passed = False
        self.create_asterisk()

    def readResult(self):
        logger.debug("Reading results")
        self.ast[0].cli_exec("core show locks")   # get lock output in case of deadlock before tearing down.
        self.ast[0].cli_exec("core show channels")# if channels are still up for some reason, we want to know that as well
        self.stopProcesses()

        if self.passed == True:
            logger.info('SIP Transfer Test Passed!')
        else:
            logger.error('SIP Transfer Test Failed')
        self.stop_reactor()

    def ami_connect(self, ami):
        TestCase.ami_connect(self, ami)

        # start up the processes
        self.startProcesses()
        reactor.callLater(5, self.cCallB)
        reactor.callLater(10, self.bCallA)
        reactor.callLater(15, self.bTransferAToC)
        reactor.callLater(20, self.amiCheckBridge)

        # stop and read results after timeout
        reactor.callLater(25, self.readResult)


    def checkBridgeResult(self, result):
        logger.debug('Result %s' % str(result))
        if "bridgedchannel" not in result[0]:
            logger.debug("bridgedchannel was not a valid key; checking for link")
            if "link" not in result[0]:
                logger.warn("'link' and 'bridgedchannel' not found")
            elif result[0]['link'] == 'SIP/end_a-00000001': # check link for older versions of asterisk
                self.passed = True
        elif result[0]['bridgedchannel'] == 'SIP/end_a-00000001':
            self.passed = True

        if self.passed == True:
            logger.debug("Found Bridge!!!")
        else:
            logger.warn("Detecting Bridge failed")


    def checkBridgeError(self, reason):
        logger.error(reason.getTraceback())
        logger.error("Checking Bridge failed.  Channel did not exist.")
        reactor.callLater(1, self.readResult)

    def amiCheckBridge(self):
        logger.debug("Get AMI results")
        self.ami[0].status('SIP/end_c-00000002').addCallbacks(self.checkBridgeResult, self.checkBridgeError)
        self.reset_timeout()

    def cCallB(self):
        logger.info("C Calling B")
        self.pjc.stdin.write("m\n")
        self.pjc.stdin.write("sip:127.0.0.1:5066\n")
        self.reset_timeout()

    def bCallA(self):
        logger.info("B Calling A")
        self.pjb.stdin.write("m\n")
        self.pjb.stdin.write("sip:call_a@127.0.0.1:5060\n")
        self.reset_timeout()

    def bTransferAToC(self):
        logger.info("B Transfering A to C")
        self.pjb.stdin.write("X\n")
        self.pjb.stdin.write("1\n")
        self.reset_timeout()

    def startProcesses(self):
        logger.info("Starting Processes")
        self.pja = subprocess.Popen(['pjsua', '--local-port=5065',
                                     '--auto-answer=200', '--null-audio'],
                                     stdin=subprocess.PIPE,
                                     stdout=subprocess.PIPE)
        self.pjb = subprocess.Popen(['pjsua', '--local-port=5066',
                                     '--auto-answer=200', '--null-audio'],
                                     stdin=subprocess.PIPE,
                                     stdout=subprocess.PIPE)
        self.pjc = subprocess.Popen(['pjsua', '--local-port=5067',
                                     '--auto-answer=200', '--null-audio'],
                                     stdin=subprocess.PIPE,
                                     stdout=subprocess.PIPE)

    def stopProcesses(self):
        logger.info("Stopping Processes")
        os.kill(self.pja.pid, signal.SIGKILL)
        os.kill(self.pjb.pid, signal.SIGKILL)
        os.kill(self.pjc.pid, signal.SIGKILL)

    def run(self):
        TestCase.run(self)
        self.create_ami_factory()

def main():
    # Run Transfer Test
    transfer_test = OneLeggedTransfer()

    transfer_test.start_asterisk()
    reactor.run()
    transfer_test.stop_asterisk()
    if transfer_test.passed != True:
        return 1
    return 0

if __name__ == "__main__":
    sys.exit(main() or 0)

