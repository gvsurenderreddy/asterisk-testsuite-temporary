#!/usr/bin/env python
'''
Copyright (C) 2010, Digium, Inc.
David Vossel <dvossel@digium.com>

This program is free software, distributed under the terms of
the GNU General Public License Version 2.
'''

import sys
import os
import math
from twisted.application import service, internet
from twisted.internet import reactor, defer
from starpy import manager

sys.path.append("lib/python")
from asterisk.asterisk import Asterisk

workingdir = "feature_blonde_transfer"
testdir = "tests/%s" % workingdir

class BlondeTransferTest:
    def __init__(self):
        self.passed = False
        self.alpha = False
        self.bravo = False
        self.charlie = False

        # Test timeout in seconds
        self.test_to = 45

        reactor.callWhenRunning(self.run)

        self.ast1 = Asterisk(base=workingdir)
        self.ast1.install_configs("%s/configs/ast1" % (testdir))

        self.ast2 = Asterisk(base=workingdir)
        self.ast2.install_configs("%s/configs/ast2" % (testdir))


    def check_result(self):
        self.log_last_step("Checking results...")
        if self.alpha is True and self.bravo is True and self.charlie is True:
            self.stop_reactor()
            self.passed = True

    def stop_reactor(self):
        def __finish_stop(result):
            print "Stopping Reactor ..."
            if reactor.running:
                reactor.stop()
            return result
        df = self.ast1.stop()
        df.addCallback(__finish_stop)

    def launch_test(self):
        self.ast2.cli_originate("Local/1000@transfertest extension a_dial@transfertest")

    def log_last_step(self, step):
        print step
        self.last_step = step

    def check_alpha(self, ami, event):
        self.log_last_step("Checking Userevent")
        if event.get("userevent").lower() != "alpha":
            return
        status = event.get("status")
        print ("Status of alpha is %s" % (status))
        if status != "SUCCESS":
            self.stop_reactor()
            return

        self.alpha = True
        self.check_result()

    def check_bravo(self, ami, event):
        self.log_last_step("Checking Userevent")
        if event.get("userevent").lower() != "bravo":
            return
        status = event.get("status")
        print ("Status of bravo is %s" % (status))
        if status != "SUCCESS":
            self.stop_reactor()
            return

        self.bravo = True
        self.check_result()

    def check_charlie(self, ami, event):
        self.log_last_step("Checking Userevent")
        if event.get("userevent").lower() != "charlie":
            return
        status = event.get("status")
        print ("Status of charlie is %s" % (status))
        if status != "SUCCESS":
            self.stop_reactor()
            return

        self.charlie = True
        self.check_result()

    def ami_on_connect2(self, ami):
        self.log_last_step("Connected to AMI 2")
        self.ami2 = ami
        self.ami2.registerEvent("UserEvent", self.check_bravo)

    def ami_on_connect1(self, ami):
        self.log_last_step("Connected to AMI 1")
        self.ami1 = ami
        self.ami1.registerEvent("UserEvent", self.check_alpha)
        self.ami1.registerEvent("UserEvent", self.check_charlie)

    def ami_login_error(self, ami):
        self.log_last_step("AMI login failed")
        self.stop_reactor()

    def ami_login(self):
        self.log_last_step("Logging in to the AMI")
        self.ami_factory1 = manager.AMIFactory("user", "mysecret")
        self.ami_factory1.login('127.0.0.1', 5038).addCallbacks(self.ami_on_connect1, self.ami_login_error)
        self.ami_factory2 = manager.AMIFactory("user", "mysecret")
        self.ami_factory2.login('127.0.0.2', 5038).addCallbacks(self.ami_on_connect2, self.ami_login_error)

    def run(self):
        def __finish_start_ops(result):
            self.ami_login()
            self.launch_test()

            # stop and read results after timeout
            reactor.callLater(self.test_to, self.stop_reactor)

        self.log_last_step("Starting Asterisk")
        df1 = self.ast1.start()
        df2 = self.ast2.start()
        dl = defer.DeferredList([df1, df2])
        dl.addCallback(__finish_start_ops)

def main():
     # Run Blonde Transfer Test
    test = BlondeTransferTest()
    reactor.run()
    if test.passed != True:
        return 1
    return 0

if __name__ == "__main__":
    sys.exit(main() or 0)

# vim:sw=4:ts=4:expandtab:textwidth=79
